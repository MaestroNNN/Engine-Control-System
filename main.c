/*Этот код реализует автоматическое управление двигателем на основе ПИД-регулятора:

Читается ультразвуковой датчик ? конвертация расстояния.
Вычисляется ошибка между желаемым и текущим положением.
Рассчитывается ПИД-регулирование ? определение U.
Определяется направление вращения (через реле).
Формируется ШИМ-сигнал для управления скоростью двигателя.
Передача данных по UART для отладки.
Код рабочий, но можно улучшить:

Использовать аппаратный таймер для формирования ШИМ, а не программные задержки.
Оптимизировать усреднение сигнала датчика.
Улучшить параметры ПИД-регулятора (например, автонастройка kp, ki, kd). 
============ Входы цифровые ============
PA0 - PA1 - биты для АЦП
============ Выходы цифровые ============
PB1 - ШИМ сигнал
PB5 - PB8 - управление реле
=============== Служебные ===============
USART1: PA9 = TX1, PA10 = RX1 */

#include "stm32f10x.h"
#include "main_functions.c" 
#include "main_init.c"

// ================== Описание глобальных переменных =============
/*result1 — сырое значение с АЦП (сигнал от датчика)
y — преобразованное расстояние в см
pir — усредненное значение сигнала с датчика
kp, ki, kd — коэффициенты ПИД-регулятора
e — ошибка регулирования (разница между желаемым и текущим положением)
U — управляющее воздействие на двигатель
Timer, t1_c, t2_c — вспомогательные таймеры для работы системы*/
volatile uint16_t Timer = 0, shift_i = 65000;
uint8_t mass[6],i, kk=0;
volatile uint16_t result1 = 0, t1=0, t2=0, T=0, d=0, usart_t=0;
volatile int32_t  r=0, e=0,  y=0, h=0, U = 0, pir = 0,yy[5]={0}, raz = 0, raz1 = 0, sum = 0, ki = 0, kp = 0, kd = 0;
volatile uint16_t t1_c=0, t2_c=0;
volatile uint8_t k = 0;
static volatile u8 ch;


// ============== Подпрограммы обработки прерывания ==============
// ============ USART1 в данном проекте не используется ==========
// USART1->SR, бит RXNE сбрасывается автоматически при чтении USART1->DR,
// записывать в него ноль нужно только при мультибуферной коммуниуации.

void USART1_IRQHandler() {
  ch = USART1->DR; 
}  

// =================== TIM2 100 мкс ===================
/*Прерывание вызывается каждые 100 мкс, выполняет вспомогательные задачи:
Обрабатывает таймеры (Timer, t1_c, t2_c).
Управляет состоянием реле (переключает GPIOB->BSRR).
Мигает светодиодом (из закомментированного кода).*/
void TIM2_IRQHandler() {
  if ((TIM2->SR & TIM_SR_UIF) != 0) { // Прерывание по переполнению
    TIM2->SR &= ~ TIM_SR_UIF; 
	if(Timer>0){Timer--;}
	if(Timer==0 && (GPIOC->IDR & GPIO_IDR_IDR13)!=0){GPIOC->BSRR |= GPIO_BSRR_BR13; Timer=5000;}
	if(Timer==0 && (GPIOC->IDR & GPIO_IDR_IDR13)==0){GPIOC->BSRR |= GPIO_BSRR_BS13; Timer=5000;}
	
	if(t1_c>0){t1_c--;}
	if(t2_c>0){t2_c--;}
	if(shift_i>0){shift_i--;}
	if(usart_t>0){usart_t--;}
	
	if(t1_c==0 && k==1){GPIOB->BSRR |= GPIO_BSRR_BR1; t2_c = t2, k=2;}
	if(t2_c==0 && k==2){GPIOB->BSRR |= GPIO_BSRR_BS1; t1_c = t1; k=1;}
	
 //   GPIOC->ODR ^= GPIO_ODR_ODR13; // Мигаем светодиодом PC8
  }
}  

// =========================== MAIN =========================
int main(void) {
/*Настраивается АЦП для считывания сигнала с ультразвукового датчика.
Настраивается USART1 для отладки через последовательный порт.
Включается TIM2, который выполняет обработку времени каждые 100 мкс.
Настраиваются порты GPIO для управления реле и ШИМ.*/
main_init(); // Инициализация МК

	T=1000;
	t1 = T * d / 100;
	t2 = T - t1;
	k=1;
	r = 150; //Желаемое значение (уставка)
// ========================= ГЛАВНЫЙ ЦИКЛ =========================
// В бесконечном цикле (while(1)) выполняется управление двигателем:
while (1) {
	/*	Чтение данных с АЦП 
	Запускается АЦП, ожидается завершение преобразования, 
	затем считывается значение (result1).*/
	// Устанавливаем последовательность преобразования	  		 
	ADC1->SQR3 &=~ADC_SQR3_SQ1; // Обнуляем регистр для выбора канала 1
	ADC1->CR2|=ADC_CR2_ADON;
    while((ADC1->SR&ADC_SR_EOC)==0){};
	result1 = ADC1->DR; //значения с АЦП от 00200 до 02500
 	/*94 — это пороговое значение АЦП при нулевом расстоянии (калибровка). То есть, когда объект максимально близко к датчику, АЦП выдаёт 94.
	10 / 65 — коэффициент преобразования напряжения в расстояние.
	65 — разница значений АЦП на каждые 10 см.
	То есть на 65 единиц АЦП приходится 10 см.*/
	y =(result1-94)*10/65; // Преобразование значений с АЦП к см
	/*Фильтрация данных (скользящее среднее)
	Используется усреднение по 5 измерениям для уменьшения шума.*/
	h = 5;
	for (i = h-1; i > 0; i--){yy[i] = yy[i-1];}
	yy[0] = y;
	pir = 0;
	for (i = 0; i < h; i++){pir = pir + yy[i];}
	pir = pir / h; // Среднее значение сигнала с датчика
	
	kp = 50; //Kp/1000
	ki = 30; //Ki/1000
	kd = 0; //Kd/1000
	/*ПИД-регулятор
	Вычисляется ошибка (разница между желаемым и текущим положением).
	Применяется гистерезис (мёртвая зона), чтобы избежать дребезга:*/
	e=r-pir; //Значение ошибки (желаемое - реальное)
	
	if(e<2 && e>-2 ) {e = 0;} //Зона отработки ошибки, чтобы избежать дребезга реле
	
	if(U!=100 && U!=-100){sum = sum + e*(65000-shift_i)/100;} // Интегратор

	raz = e - raz1/(65000-shift_i)*100; //Дифференциатор 
	raz1 = e;
	
	shift_i = 65000;
	
	U = e*kp/1000 + sum*ki/100000 + raz*kd/1000; //ПИД-регулятор
	/*Нормируется U в диапазон [-100, 100].
	Вводится зона нечувствительности, чтобы двигатель не дёргался*/
	if (U > 100) {U = 100;}//Saturation
	if (U < -100) {U = -100;}//Saturation
	if (U < 5 && U >0) {U = 0;}//Dead Zone
	if (U > -5 && U <0) {U = 0;}//Dead Zone
	if (U > -3 && U <3) {U = 0;}
	if(y>340 && U>0){U=0;}//Ограничение по перемещению вправо
	if(y<20 && U<0){U=0;}//Ограничение по перемещению влево
	
	if (U < 0 ) {d = -U;}
	else {d = U;}
	/*Формирование ШИМ
	В зависимости от U, вычисляются t1 и t2 (время включения и выключения):*/
	t1 = T * d / 100;
	t2 = T - t1;
	/*Управление направлением двигателя через реле*/
	if (U >= 0)
	/*Отключаются реле 7 и 8.
	Включаются реле 5 и 6.*/
	{
	kk=1;
	GPIOB->BSRR |= GPIO_BSRR_BR7;
	GPIOB->BSRR |= GPIO_BSRR_BR8;
	delay_ms(100);
	GPIOB->BSRR |= GPIO_BSRR_BS5;
	GPIOB->BSRR |= GPIO_BSRR_BS6;
	}
	
	if (U < 0)
	/*Отключаются реле 5 и 6.
	Включаются реле 7 и 8.*/
	{
	kk=0;
	GPIOB->BSRR |= GPIO_BSRR_BR5;
	GPIOB->BSRR |= GPIO_BSRR_BR6;
	delay_ms(100);
	GPIOB->BSRR |= GPIO_BSRR_BS7;
	GPIOB->BSRR |= GPIO_BSRR_BS8;
	}
	
	/*Вывод данных по UART (USART1)
	Каждые 2000 тактов передаются текущие данные 
	(уставка r, измеренное y, pir, e, U, sum, raz).*/
if(usart_t==0)
	{		
		/*Tx1('r');*/
		Tx1(' '); Tx1(' ');
		Uint32ToStr(r, &mass[0]);
		Tx1Str(&mass[5]);  Tx1('\t');
		
		/*Tx1('y');*/   
		
		if(y<0)
		{Tx1('-');Uint32ToStr(-y, &mass[0]);}
		else
		{Uint32ToStr(y, &mass[0]);}
		Tx1Str(&mass[5]);  Tx1('\t');
		
		/*Tx1('pir');*/
		
		if(pir<0)
		{Tx1('-');Uint32ToStr(-pir, &mass[0]);}
		else
		{Uint32ToStr(pir, &mass[0]);}
		Tx1Str(&mass[5]);  Tx1('\t');
		
		/*Tx1('e'); Tx1(' '); Tx1('='); Tx1(' ');*/ 
		
		if(e<0)
		{Tx1('-');Uint32ToStr(-e, &mass[0]);}
		else
		{Uint32ToStr(e, &mass[0]);}
		Tx1Str(&mass[5]);  Tx1('\t');
		
		/*Tx1('U');*/
		
		if(U<0)
		{Tx1('-');Uint32ToStr(-U, &mass[0]);}
		else
		{Uint32ToStr(U, &mass[0]);}
		Tx1Str(&mass[5]);  Tx1('\t'); 
		
		/*Tx1('sum');*/
	
		if(sum<0)
		{Tx1('-');Uint32ToStr(-sum, &mass[0]);}
		else
		{Uint32ToStr(sum, &mass[0]);}
		Tx1Str(&mass[0]);  Tx1('\t');
		
		/*Tx1('raz');*/
		
		if(raz<0)
		{Tx1('-');Uint32ToStr(-raz, &mass[0]);}
		else
		{Uint32ToStr(raz, &mass[0]);}
		Tx1Str(&mass[0]);  Tx1('\r');
		

		usart_t=2000;
		ch = 0; // Обнуляем ch, иначе вывод будет постоянным (пока ch не примет другое значение)
	}	
}
} 

// КОНЕЦ